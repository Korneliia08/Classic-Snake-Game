Я створила класичну гру **"Змійка"** з використанням чистого HTML, CSS та JavaScript.
Для маніпуляцій з DOM я застосовувала jQuery, а Canvas використала для відображення ігрового поля, змійки, яблука та також відображення очок, повідомлення про те коли гра закінчена . 

Ігрове поле, яке є холстом, є основним простором для всіх дій: тут змійка рухається, збирає їжу та розвивається.

Реалізація гри була виконана з використанням об'єктно-орієнтованого підходу, що дозволило структуровано організувати код і забезпечити легкість у його підтримці.

**Основні функції гри:**
* **Емоція змійки:** Якщо змійка з'їсть біля п’яти яблук, її "ротик" починає усміхатися.
* **Колір сегментів:** При кожному старті гри змійка отримує новий колір своїх сегментів.
* **Завершення гри при зіткненні:** Гра закінчується, якщо змійка наїжджає на себе.
* **Завершення гри при зіткненні зі стінками:** Гра також закінчується, якщо змійка входить у колізію зі стінками ігрового поля.
* **Відображення очок:** Очки відображаються у лівій частині ігрового поля.

# Ось найголовніші частини коду, які відповідають за обробку колізій та логіки гри:
* ## Метод Snake.prototype.move:**
   
![move](https://github.com/Korneliia08/Classic-Snake-Game/blob/master/assets/imagesOfCode/snakeMove.png)

* Оновлює позицію голови змійки відповідно до напрямку.

* Перевіряє на колізії за допомогою методу **this.checkCollision(newHead).**

* Метод **newHead.equal(apple.position)** перевіряє, чи голова змійки перебуває на яблуку. Він повертає відповідь, і якщо результат є істинним, то яблуко змінює своє розташування, змійка виростає, а рахунок збільшується.

* Якщо яблуко не з'їдене, видаляє останній сегмент змійки.

* ## Метод Snake.prototype.checkCollision:

![checkCollision](https://github.com/Korneliia08/Classic-Snake-Game/blob/master/assets/imagesOfCode/checkCollision.png)

* Перевіряє, чи нова голова змійки стикається з краями ігрового поля (wallCollision).

* Перевіряє, чи нова голова змійки стикається з будь-яким з її сегментів (selfCollision).

* Повертає true, якщо є колізія з будь-якою частиною змійки або стінкою, інакше false.


* ## Метод Block.prototype.equal:

![equal](https://github.com/Korneliia08/Classic-Snake-Game/blob/master/assets/imagesOfCode/equel.png)

* Перевіряє, чи два блоки мають однакові координати.

* ## Функція gameOver:

  ![gameOver](https://github.com/Korneliia08/Classic-Snake-Game/blob/master/assets/imagesOfCode/gameOver.png)

* Зупиняє гру, очищуючи інтервал оновлення.
  
* Відображає повідомлення "Game over" на екрані.

* ## Обробка вводу з клавіатури

  ![eventKeyboard](https://github.com/Korneliia08/Classic-Snake-Game/blob/master/assets/imagesOfCode/event.png)

* ### Об'єкт directions:

Цей об'єкт використовує код клавіші як ключ (стрілки вліво, вгору, вправо, вниз) і відповідний напрямок як значення.

* ### Обробка події keydown:

* Встановлює обробник подій для натискання клавіші.

* При натисканні клавіші, подія передає об'єкт event, в якому є keyCode натиснутої клавіші.

* event.keyCode використовує код клавіші, щоб визначити напрямок руху, викликаний натисканням стрілки.

* Якщо keyCode є в об'єкті directions, метод snake.setDirection(nowDirection) оновлює напрямок руху змійки.

### Як це працює:
Коли натискається одна з клавіш-стрілок, відповідний код клавіші (37, 38, 39, 40) перевіряється в об'єкті directions.
Якщо код клавіші знайдено, викликається метод setDirection об'єкта snake, щоб змінити напрямок руху змійки на новий.
Цей механізм забезпечує інтерактивний контроль над рухом змійки в грі, дозволяючи гравцеві управляти змійкою за допомогою клавіатури.

## Структура ігрового поля

### Конструктор Block:

![block](https://github.com/Korneliia08/Classic-Snake-Game/blob/master/assets/imagesOfCode/block.png)

* Конструктор Block створює блоки на ігровому полі. Кожен блок визначається координатами col і row, які визначають його позицію на холсті.

* this.color задає випадковий колір блоку, що використовується для малювання.

### Змійка і яблуко:

* **Snake:** Змійка складається з масиву сегментів типу Block. Кожен сегмент представляє собою блок, який зберігається в масиві this.segments.
* **Apple:** Яблуко також представлено як об'єкт типу Block, але використовує зображення для візуалізації. Його позиція оновлюється випадковим чином, щоб уникнути перекриття з сегментами змійки.
Ця структура дозволяє організувати ігрове поле в зручний і зрозумілий спосіб, розділяючи його на рівномірні блоки, що спрощує обробку колізій та відображення об'єктів на холсті.

## Ось детальний опис інтервалу та структури ігрового поля, що складається з блоків:

![setInterval](https://github.com/Korneliia08/Classic-Snake-Game/blob/master/assets/imagesOfCode/setInterval.png)

* setInterval() створює цикл, який виконує функцію кожні 180 мілісекунд. Це визначає частоту оновлення гри.

* **ctx.clearRect(0, 0, width, height):** Очищує весь холст перед кожним оновленням, щоб уникнути залишкових зображень.
* **snake.move():** Оновлює позицію змійки, включаючи перевірку на колізії та оновлення стану (змія рухається, їсть яблуко тощо).
* **rawScore():** Відображає поточний рахунок на холсті.
* **snake.draw():** Малює сегменти змійки на холсті.
* **apple.draw():** Малює яблуко на холсті.
* **drawBorder():** Малює межі ігрового поля.

Ці частини коду є критично важливими для забезпечення основного функціоналу гри "Змійка", включаючи обробку руху, колізій та завершення гри.

## Висновок
**Об'єктно-орієнтований підхід (ООП)** використовується для чіткої організації та структурування коду, що спрощує його підтримку та розширення. Методи прототипів дозволяють спільно використовувати функції між об'єктами, зменшуючи дублювання коду і забезпечуючи легкість у модифікаціях.

**Конструктор Block** є важливим, оскільки він створює базовий елемент ігрового поля – блоки, які представляють сегменти змійки та яблука. Його використання забезпечує організоване управління позиціями і кольорами блоків, що спрощує відображення і обробку колізій у грі.

Так, блоки представляють саме ігрове поле. Конструктор Block визначає координати і колір кожного блоку, що дозволяє організувати ігрове поле у вигляді регулярної сітки. Це полегшує управління розташуванням об'єктів, таких як сегменти змійки та яблуко, а також обробку колізій між ними.

## Чому методи додані в прототипи
Методи були додані в прототипи для забезпечення повторного використання коду та зменшення дублювання. Це дозволяє всім об'єктам певного типу (наприклад, Snake або Block) спільно використовувати однакові методи, такі як move, checkCollision, або equal. Такий підхід полегшує підтримку і модифікацію коду, оскільки зміни в методах прототипу автоматично відображаються у всіх екземплярах об'єктів, що його використовують.
